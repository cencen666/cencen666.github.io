{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"","slug":"第五周总结","date":"2021-04-02T10:12:37.963Z","updated":"2021-04-02T10:12:34.501Z","comments":true,"path":"2021/04/02/第五周总结/","link":"","permalink":"http://example.com/2021/04/02/%E7%AC%AC%E4%BA%94%E5%91%A8%E6%80%BB%E7%BB%93/","excerpt":"","text":"第五周总结2021.4.2 一、”==”与“equals()”基本数据类型:使用时需要赋具体值,判断时使用“==”号引用数据类型:使用时可以赋null,判断时使用equals方法 1、**”==”：运算符** 1.可以使用在基本数据类型和引用数据类型变量中 2.如果比较的是基本数据类型，比较两个变量保存的数据是否相等（不一定类型要相同） 如果比较的是引用数据类型，比较两个对象地址值是否相同(即两个引用是否指向同一个对象实体，new了两个就不是一个对象了)==左右两边变量类型必须一致。eg：“hello”（基本数据类型）==new java.untile.Date()（引用数据类型）编译不通过 2、“equals()”：方法 1.是方法而非运算符 2.只适用于引用数据类型 3.Object类中定义的equals()和==的作用是相同的，比较两个对象的地址值是否相同，即两个引用是否指向同一个对象实体 public boolean equals(Object obj) { return (this == obj); &#125; 4.像String、Date（获取当前时间对象）、File（代表文件或者目录（文件夹）的类 ）、包装类等都重写了Object类中的equals()方法。重写以后，比较的不是两个引用的地址是否相等，而是比较两个对象的“实体内容”是否相同。 5.通常情况下，我们自定义的类如果使用equals()的话，也是通常比较两个对象的“实体内容”是否相同。那么，就 需要对Object类中的equals()进行重写 重写规则：比较两个对象的实体内容是否相同 123456789//引用数据类型 //“==” Cus cus1 = new Cus(&quot;TOM&quot;,21); Cus cus2 = new Cus(&quot;TOM&quot;,21); System.out.println(cus1==cus2);//false String str1 = new String(&quot;abcd&quot;); String str2 = new String(&quot;abcd&quot;); System.out.println(str1==str2);//false 123456789101112131415161718//equals() //属性.不出来equals(),只有类才能.出来equals，属性不包含于面向对象 System.out.println(cus1.equals(cus2));//false（原先）-&gt;true(重写以后) System.out.println(str1.equals(str2));//true /*原因：重写了equals()方法 public boolean equals(Object anObject) &#123; if (this == anObject) &#123;//引用数据的地址相同，则毫无疑问为true return true; &#125; if (anObject instanceof String) &#123; String aString = (String)anObject; if (!COMPACT_STRINGS || this.coder == aString.coder) &#123; return StringLatin1.equals(value, aString.value); &#125; &#125; return false; &#125; System.out.println(date1.equals(date2 ));//true 1234//同理Date date1 = new Date(3232323232L);Date date2 = new Date(3232323232L);System.out.println(date1.equals(date2 ));//true 例子：1.比的是对象 12345678910111213public boolean equals(Object o) &#123; if (this == o) &#123; return true; &#125; if (o instanceof Cus) &#123; Cus cus = (Cus) o; return this.age == cus.age &amp;&amp; this.name.equals(cus.name); &#125;else&#123; return false; &#125; &#125; 2.比的是对象里的基本数据类型 123456789101112public boolean equals(Object o) &#123; if (this == o) &#123; return true; &#125; if (o instanceof Cus) &#123; Cus cus = (Cus) o; return this.day == cus.day &amp;&amp; this.month == cus.month &amp;&amp; this.year == cus.year; &#125;else&#123; return false; &#125; &#125; 二、Object类java.lang.Object类 1.Object类是所有Java的根父类 2.如果在类的声明中未使用extends关键字指明其父类，则默认父类为java.lang.Object类 3.Object类中的功能（属性和方法）具有通用性 属性：无 方法：equals() / toString() / getClass() / hashCode() / clone() / finalize() 4.Obejct类只声明了一个空参的构造器 三、toString的使用Object类中toString的使用：(只对类使用） 1.当我们输出一个对象引用时(s)，实际上就是调用当前对象的toString() Cus s = new Cus(); System.out.println(s);//地址值：Cus@7ef20235 System.out.println(s.toString());//地址值：Cus@7ef20235 2.Object类中定义的toString方法 public String toString() { return getClass().getName() + “@” + Integer.toHexString(hashCode()); } //调用方法类的类名（getClass().getName()）@根据hashcode值(hashCode())计算出在堆空间的一个存储位置并把它转化为16进制（toHexString） 3.像String、Data、File、包装类都重写了Object类中的toString()方法，使得在调用对象的toString()时，发返回“实体内容”的信息 4.自定义类也可以重写toString()方法，当调用此方法时，返回对象为“实体内容” 5.toString的对象如果是null；即例如 s.toString ；s==null；结果会出现异常：空指针 输出实体内容需要重写 123Cus s = new Cus();System.out.println(s);//地址值：Cus@7ef20235-&gt;i = 1 age = 2System.out.println(s.toString());//地址值：Cus@7ef20235-&gt;i = 1 age = 2 重写： 1234567public class Cus &#123; int i = 1; int age = 2; public String toString()&#123; return &quot;i = &quot;+ i +&quot; &quot;+&quot;age = &quot;+age; &#125;&#125; 面试题：1. 12345678910111213141516171819@Test public void test3()&#123; Integer i = new Integer(1); Integer J = new Integer(1); System.out.println(i==J);//false,比地址不是同一个对象 //原因：Integer里边有一个方法交IntegerCache //其中定义了一个叫Integer[]数组包含数字-128~+127，因为使用经常只在这段数字之中，如此可以提高效率 //如果我们使用自动装箱方式，给Integer赋值范围在-128~127时，可以直接调用，就不用new了 // 如下使用是的1是从里边调用的，因此返回true //而128超出了该数组范围所以返回false Integer m = 1; Integer n = 1; System.out.println(m==n);//true, Integer x = 128; Integer Y = 128; System.out.println(x==Y);//false &#125; 2. 12345678910@Test public void test2()&#123; Object o2; if(true)&#123; o2 = new Integer(1); &#125;else&#123; o2 = new Double(2.0); &#125; System.out.println(o2);//1 &#125; 3. 123456@Test public void test1()&#123; Object o1 = true?new Integer(1):new Double(2.0); //要求“：”前后类型一致，所以1变成1.0 System.out.println(o1);//--&gt;1.0 &#125; 三、单元测试Java中的IUnite单元测试即不用主函数也可以运行 步骤：1.选中需要测试的类名-&gt;右键选GO TO-&gt;选Test-&gt;JUnit42.创建java类进行单元测试此时的Java类要求：（1）此类是public的（2）此类提供公共的无参构造器3.此类中声明单元测试的方法：此时的单元测试方法：方法的权限是public，没有返回值，没有形参 4.此单元测试方法上需要声明注释：*@Test，并在单元测试中导入import org.junit.;**5.声明好单元方法后就可以在方法体内测试相关代码 12345678910import org.junit.*;public class JUnitTest &#123; @Test public void testEquals()&#123; String s1 = &quot;ww&quot;; String s2 = &quot;ss&quot;; System.out.println(s1.equals(s2)); &#125;&#125; 四、包装类目的：使基本数据类型具有类的特征 包装类的使用： 1.Java提供了8种基本数据类型对应的包装类，使得基本数据类型具有类的特征； 2.掌握基本数据类型、包装类、String三者之间的关系 (1)自动装箱拆箱 在JDK1.5之前，所有的数据必须进行手工的装箱及拆箱操作。而且包装类本身不能进行任何的数学运算。 在JDK1.5之后加了很多的新特性：如foreach、可变参数，及自动的装箱和拆箱。 装箱操作：将基本数据类型变为包装类称为装箱; int num =10; Integer in = num; 拆箱操作：把包装类型，变为基本类型称为拆箱操作 boolean b1 = true; Boolean b2 =b1; (2) 基本数据类型—-valueOf()—&gt;String类 12345678910111213public void test3() int num = 10; //String str = num;---&gt;错误 //改正： //方式一： String str = num+&quot;&quot;; //方式二： String str1 = String.valueOf(num); Double d1 = new Double(12.4); String str3 = String.valueOf(d1); System.out.println(str3); &#125; String()—parseXxx(String)—&gt;基本数据类型//特别重要 1234567891011121314151617public void test4()&#123; String a = &quot;123&quot;;// int A = (int)a;基本数据类型不能强转类// Integer IN = (Integer)a;//没有子父类关系的也不能强转 //有可能报错：NumberFormatException Integer NUM = Integer.parseInt(a); System.out.println(NUM); //boolean型只要不是true就会显示false，但不会报错 String str2 = &quot;true&quot;; String str3 = &quot;true23&quot;; boolean b2 = Boolean.parseBoolean(str2); boolean b3 = Boolean.parseBoolean(str2); System.out.println(b2);//--&gt;true System.out.println(b3);//---&gt;false &#125; 包装类—toString()—&gt;String类 123456789 public void test1()&#123; int num1 = 10;// System.out.println(num1.toString()); Integer num2 = new Integer(num1);//要转成一个类才能使用toString() System.out.println(num2.toString()); Integer num3 = new Integer(&quot;123&quot;); System.out.println(num3.toString()); 特别说明 1234567891011121314151617181920212223242526272829303132333435363738 public void test1()&#123; int num1 = 10;// System.out.println(num1.toString()); Integer num2 = new Integer(num1); System.out.println(num2.toString()); Integer num3 = new Integer(&quot;123&quot;); System.out.println(num3.toString());//Integer要求为纯粹一个数才能打印出，虽然也可以是字符串，但字符串也必须且只能含有数字// Integer num4 = new Integer(&quot;123abv&quot;);// System.out.println(num4.toString());//报异常//Boolean被优化了，如下：equalsIgnoreCase()为不分大小写，相等即可入True.equalsIgnoreCase(true)=true// public static boolean parseBoolean(String s) &#123;// return &quot;true&quot;.equalsIgnoreCase(s);// &#125; //即长得和true一样则为true,否则为false，但不会报异常 Boolean b1 = new Boolean(true); Boolean b2 = new Boolean(&quot;true&quot;); Boolean b3 = new Boolean(&quot;true123&quot;); Boolean b4 = new Boolean(&quot;TruE&quot;); System.out.println(b1);//-&gt;true System.out.println(b2);//-&gt;true System.out.println(b3);//-&gt;false System.out.println(b4);//-&gt;true System.out.println(new Order().b);//-&gt;false System.out.println(new Order().A);//-&gt;null:因为他已经升级为一个类了，类的默认值即为null &#125;&#125;//特别注意class Order&#123; boolean b; Boolean A;&#125; 五、static关键字static关键字的使用 1.static:静态的 2.static：可以用来修饰、属性、方法、代码块、内部类 3.使用static修饰属性：静态变量(或类变量) 3.1：属性：按是否使用static修饰，又分为：静态变量 VS 非静态变量（实例变量） 实例变量：创建了类的多个对象，每个对象都独立的拥有一套类中的非静态变量属性。当修改其中一个对象的非静态属性时，不会导致其他其他对象中同样的属性值被修改。 静态变量：创建了类的多个对象，多个对象共享同一个静态变量。当通过某一个对象修改静态变量时，会导致其他对象调用此静态变量时，是修改过了的 3.2：static修饰属性的其他说明： （1）静态变量随着类的加载而加载，可以通过“类.静态变量”的方式进行调用 （2）静态变量的加载要早于对象的创建 （3）由于类只会加载一次，则静态变量在内存中也只会存在一份，存在方法区的静态域中 4.使用static修饰方法： （1）静态变量随着类的加载而加载，可以通过“类.静态方法”的方式进行调用 （3）静态方法中，只能调用非静态的属性和方法 非静态方法中，既能调用静态的属性和方法，也能调用非静态的属性和方法 1234567891011121314151617181920212223242526class Chinese&#123; String name; int age; static String nation; public static void show()&#123;// name = &quot;WOO&quot;;//不能调用非静态属性// info();//不能调用非静态属性 //可以使用非静态结构 System.out.println(Chinese.nation); System.out.println(nation);//省略Chinese. &#125; public void info()&#123; &#125; public void infoo()&#123; //可以调用非静态结构 this.info(); System.out.println(name); //可以调用静态结构 System.out.println(Chinese.nation); info(); &#125; （4）static注意点： 在静态方法中，不能使用this关键字、super关键字、 生命周期角度考虑 5.开发中如何确定一个属性是否要声明为static？ &gt;属性可以被多个对象所共享的，不会随着对象不同而不同 开发中如何确定一个方法是否要声明为static？ &gt;操作静态属性的方法，通常设置为static &gt;工具类中的方法，习惯上声明为static。比如：Math、Arrays、Collections 例子： 1234567891011121314151617181920212223242526272829public class StaticTest &#123; public static void main(String[] args) &#123; Chinese.nation = &quot;中国&quot;;//（2）静态变量的加载要早于对象的创建 Chinese c1 = new Chinese(); c1.age = 12; c1.nation = &quot;CHIN&quot;; Chinese c2 = new Chinese(); c2.age = 14; c2.nation = &quot;TAil&quot;;// Chinese.age = 14;//类不能调用实例变量 System.out.println(c1.age);//--&gt;12 System.out.println(c2.age);//--&gt;14 System.out.println(c1.nation);//--&gt;TAil System.out.println(c2.nation);//--&gt;TAil//----------------------------------------------// Chinese c2 = new Chinese();// c2.nation = &quot;TAil&quot;;//// Chinese c1 = new Chinese();// c1.age = 12;// c1.nation = &quot;CHIN&quot;;//// System.out.println(c1.nation);//--&gt;CHIN// System.out.println(c2.nation);//--&gt;CHIN &#125;&#125; 6.共享功能 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class Test1 &#123; public static void main(String[] args) &#123; Circle c1 = new Circle(); Circle c2 = new Circle(); System.out.println(c1.getId());//1001，第一次调用 System.out.println(c2.getId());//1002，第二次调用需要++ System.out.println(c1.getIdd());//1001，全当第一次调用 System.out.println(c2.getIdd());//1001 &#125;&#125;class Circle&#123; private double r; private int id; private int idd; public Circle()&#123; id = init++; idd = initt++; &#125; public Circle(double r)&#123; this();//调用空参构造器，代替了低下两个式子// id++;// total++; this.r = r; &#125; private static int total; private static int init = 1001;//体现共享 private int initt = 1001; public double findArea()&#123; return 3.14 * r * r; &#125; public int getId() &#123; return id; &#125; public int getIdd() &#123; return idd; &#125; public int getInitt() &#123; return initt; &#125;&#125; 作用：","categories":[],"tags":[]},{"title":"","slug":"2021-3-27","date":"2021-03-27T12:31:31.494Z","updated":"2021-03-27T12:49:43.985Z","comments":true,"path":"2021/03/27/2021-3-27/","link":"","permalink":"http://example.com/2021/03/27/2021-3-27/","excerpt":"","text":"第四周总结2021.3.22到2021.3.26 @[TOC]","categories":[],"tags":[]},{"title":"","slug":"2021-3-25","date":"2021-03-25T15:03:24.424Z","updated":"2021-03-27T12:51:53.119Z","comments":true,"path":"2021/03/25/2021-3-25/","link":"","permalink":"http://example.com/2021/03/25/2021-3-25/","excerpt":"","text":"搜索算法DFS与BFS2021.3.25","categories":[],"tags":[]},{"title":"","slug":"2021-03-24","date":"2021-03-24T12:47:20.838Z","updated":"2021-03-27T12:58:03.133Z","comments":true,"path":"2021/03/24/2021-03-24/","link":"","permalink":"http://example.com/2021/03/24/2021-03-24/","excerpt":"","text":"2021.3.14-2021.3.21总结 目录一、java学习 继承性 方法重写 java版管理系统 二、算法 A - Crossing River B - Oil Deposits","categories":[],"tags":[]},{"title":"","slug":"小知识1","date":"2021-03-15T15:35:40.283Z","updated":"2021-03-15T15:35:04.571Z","comments":true,"path":"2021/03/15/小知识1/","link":"","permalink":"http://example.com/2021/03/15/%E5%B0%8F%E7%9F%A5%E8%AF%861/","excerpt":"","text":"20210315考核问题： 一、this关键字this表示当前对象或正在创建的对象 使用方法：1. “this.属性”或“this . 方法”调用当前对象属性和方法;常用：this.参数名=参数名 ;2.this();表示无参构造方法; 无参构造方法一般是用来初始化：如为变量赋处置，初始化对象等。 无参构造方法可以去除，JAVA会给每个类一个默认的无参构造方法；当一个类中若存在有参构造方法，若想再使用无参的构造方法，就必须写出无参构造方法。 在类中若存在有参构造方法时，最好加上一个无参构造方法。3.this(参数列表)表示有参构造方法;！！！构造器=构造方法 eg： 12345678910//1public Person (int age)&#123; this();//调用了无参构造方法 this.age = age;&#125;//2public Person (String name, int age)&#123; this(age);//根据参数可知其进入1 this.name = name;&#125; 二、接口接口中都是抽象方法即使定义了非抽象方法，它默认也是抽象的方法，实现类必须重写，只是省略的关键字abstract，实际上接口会自动给加上","categories":[],"tags":[]},{"title":"","slug":"2021-03-10","date":"2021-03-12T16:22:37.923Z","updated":"2021-03-15T15:37:29.677Z","comments":true,"path":"2021/03/13/2021-03-10/","link":"","permalink":"http://example.com/2021/03/13/2021-03-10/","excerpt":"","text":"20210307考核错题 总结通过这次考核，首先看出了自己在寒假学习仍存在许多细节上的漏洞，同时学习速度也非常慢，题目中有一些关于接口的问题都一知半解，这需要在这两个周逐渐加快学习进度，对java进一步学习，除此之外，算法题一直都是我的一个大问题，从周日开始我坚持每天至少在leetcode上刷一道题目，由浅入深，循序渐进，希望在这个学期结束之前能让自己算法能力有一个大的进步。","categories":[],"tags":[]},{"title":"","slug":"学生证管理系统","date":"2021-01-24T07:25:36.458Z","updated":"2021-01-24T07:25:23.028Z","comments":true,"path":"2021/01/24/学生证管理系统/","link":"","permalink":"http://example.com/2021/01/24/%E5%AD%A6%E7%94%9F%E8%AF%81%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/","excerpt":"","text":"一、系统的大致内容1.用户的注册登录2.录入学生证信息3.显示学生证信息4.查询学生证信息1.按学号 2.按姓名 3.按班级 5.删除学生证信息6.排序学生证信息1.按学号 2.按班级 7.修改学生证信息1.改姓名 2.改年龄 3.改班级 二、具体代码 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; void menu(); struct Stu*creat(); //创建 void Print(); //显示 void Modify(); //修改 void Sort(); //排序 int Delect(struct Stu *); //删除 int login(); void searchname();//按名字查 void classname();//按班级查找 void stunums();//按学号 struct denglu &#123; char usename[50]; char password[50]; &#125;denglu[100]; struct Stu &#123; char name[100]; char sex[10]; int stu_num; int age; char Classname[20]; struct Stu*next; &#125;Stu[100]; struct Stu *pend=NULL; struct Stu *phead=NULL; int n=0; int m=0; int r=0; /*主函数*/ int main() &#123; FILE*fp; struct Stu*p; struct Stu *stu=NULL; int s; int choice=0; login(); system(&quot;cls&quot;); printf(&quot;***********登陆成功***********\\n&quot;); while(1) &#123; menu(); printf(&quot;请输入需要实现的功能编号：&quot;); scanf(&quot;%d&quot;,&amp;choice); switch(choice) &#123; system(&quot;cls&quot;); case 0: &#123; printf(&quot;[录入学生证信息]\\n&quot;); creat(); break; &#125; case 1: &#123; printf(&quot;-------------[显示学生证信息]-------------\\n&quot;);//读取文件内容 Print(phead); printf(&quot;**当前有%d名学生信息**\\n\\n&quot;,m); printf(&quot;------------------------------------------\\n\\n&quot;); break; &#125; case 2: &#123; printf(&quot;-------------[查询学生证信息]-------------\\n&quot;); printf(&quot;请选择查询方式 1.按学号查询 2.按姓名查询 3.按班级查询 4.查询完毕: &quot;); scanf(&quot;%d&quot;,&amp;s); while(1) &#123; if(s&gt;0 &amp;&amp; s&lt;5) &#123; if(s==1) &#123; stunums(); &#125; if(s==2) &#123; searchname(); &#125; if(s==3) &#123; classname(); &#125; if(s==4) &#123; printf(&quot;结束查询!\\n&quot;); break; &#125; printf(&quot;------------------------------------------\\n&quot;); printf(&quot;请选择查询方式 1.按学号查询 2.按姓名查询 3.按班级查询 4.查询完毕: &quot;); scanf(&quot;%d&quot;,&amp;s); printf(&quot;\\n&quot;); &#125; else &#123; printf(&quot;输入错误！请重新输入\\n&quot;); printf(&quot;------------------------------------------\\n&quot;); printf(&quot;请选择查询方式 1.按学号查询 2.按姓名查询 3.按班级查询 4.查询完毕: &quot;); scanf(&quot;%d&quot;,&amp;s); printf(&quot;\\n&quot;); &#125; &#125; printf(&quot;------------------------------------------\\n\\n&quot;); break; &#125; case 3: &#123; printf(&quot;-------------[删除学生证信息]-------------\\n&quot;); Delect(phead); printf(&quot;------------------------------------------\\n\\n&quot;); break; &#125; case 4: &#123; printf(&quot;-------------[排序学生证信息]-------------\\n&quot;); Sort(); printf(&quot;------------------------------------------\\n\\n&quot;); break; &#125; case 5: &#123; printf(&quot;-------------[修改学生证信息]-------------\\n&quot;); Modify(); printf(&quot;------------------------------------------\\n\\n&quot;); break; &#125; case 6: &#123; printf(&quot;----------------[退出登录]-----------------\\n&quot;); exit (0); break; &#125; default: &#123; printf(&quot;------------------[错误]------------------\\n&quot;); printf(&quot;-----------请重新输入0~6的数字------------\\n&quot;); printf(&quot;------------------------------------------\\n\\n&quot;); break; &#125; &#125; &#125; Print(phead); printf(&quot;\\n&quot;); system(&quot;pause&quot;); return 0; &#125; /*查询菜单*/ void menu() &#123; printf(&quot;_______________________________\\n&quot;); printf(&quot;|* 0:录入学生证信息 *|\\n&quot;); printf(&quot;|* 1:显示学生证信息 *|\\n&quot;); printf(&quot;|* 2:查询学生证信息 *|\\n&quot;); printf(&quot;|* 3:删除学生证信息 *|\\n&quot;); printf(&quot;|* 4:排序学生证信息 *|\\n&quot;); printf(&quot;|* 5:修改学生证信息 *|\\n&quot;); printf(&quot;|* 6:退出程序 *|\\n&quot;); printf(&quot;|_____________________________|\\n\\n&quot;); &#125; /*登录*/ int login() &#123; struct denglu stu[100]; FILE*fp; char user[50]; char passwords[50]; int a; int i; printf(&quot;请选择 1.用户登录 2.用户注册 3.退出系统： &quot;); scanf(&quot;%d&quot;,&amp;a); if(a==1) &#123; printf(&quot;请输入含10位以内的用户名(不允许存在空格)： &quot;); scanf(&quot;%s&quot;,user); printf(&quot;请输入含10位以内密码(不允许存在空格)： &quot;); scanf(&quot;%s&quot;,passwords); fp=fopen(&quot;D:\\\\实验室\\\\学生证管理系统\\\\学生证系统登录.txt&quot;,&quot;r&quot;); if(fp==NULL) &#123; printf(&quot;错误！\\n&quot;); return 0; &#125; int c = 0; while(!feof(fp)) &#123; fscanf(fp,&quot;%s %s\\n&quot;, &amp;stu[c].usename,&amp;stu[c].password); c++; &#125; for(i=0;i&lt;c;i++) &#123; if(strcmp(stu[i].usename,user)==0 &amp;&amp; strcmp(stu[i].password,passwords)==0) &#123; fclose(fp); return; &#125; &#125; printf(&quot;不存在此用户！\\n\\n&quot;); login(); &#125; else if(a==2) &#123; fp=fopen(&quot;D:\\\\实验室\\\\学生证管理系统\\\\学生证系统登录.txt&quot;,&quot;r&quot;); if(fp==NULL) &#123; printf(&quot;错误！\\n&quot;); &#125; int c=0; while(!feof(fp)) &#123; fscanf(fp,&quot;%s %s\\n&quot;, &amp;stu[c].usename,&amp;stu[c].password); c++; &#125; fclose(fp); printf(&quot;请输入含10位以内的用户名(不允许存在空格)： &quot;); scanf(&quot;%s&quot;,&amp;user); printf(&quot;请输入含10位以内密码(不允许存在空格)： &quot;); scanf(&quot;%s&quot;,&amp;passwords); for(i=0;i&lt;c;i++) &#123; if(strcmp(stu[i].usename,user)==0 &amp;&amp; strcmp(stu[i].password,passwords)==0) &#123; printf(&quot;已存在此用户！\\n&quot;); login(); &#125; &#125; fp=fopen(&quot;D:\\\\实验室\\\\学生证管理系统\\\\学生证系统登录.txt&quot;,&quot;a&quot;); fprintf(fp,&quot;%s %s\\n&quot;,user,passwords); // printf(&quot;%s %s\\n&quot;,user,passwords); r++; fclose(fp); printf(&quot;*****注册成功，请重新登录*****\\n\\n&quot;); login(); &#125; else if(a==3) &#123; printf(&quot;*****成功退出系统*****\\n&quot;); exit (0); &#125; else &#123; printf(&quot;请输入数字1~3\\n&quot;); login(); &#125; &#125; /*录入*/ struct Stu*creat() &#123; FILE*fp; struct Stu*p; struct Stu stu[100]; struct Stu stub[100]; struct Stu *head; struct Stu *p1,*p2; char w; int n=0; fp=fopen(&quot;D:\\\\实验室\\\\学生证管理系统\\\\学生证信息.txt&quot;,&quot;r&quot;); if(fp==NULL) &#123; printf(&quot;文件不存在!\\n&quot;); return 0; &#125; int c = 0; while(!feof(fp)) &#123; fscanf(fp,&quot;%d %s %s %d %s\\n&quot;, &amp;stu[c].stu_num,&amp;stu[c].name,&amp;stu[c].sex,&amp;stu[c].age,&amp;stu[c].Classname); c++; &#125; fclose(fp); fp=fopen(&quot;D:\\\\实验室\\\\学生证管理系统\\\\学生证信息.txt&quot;,&quot;a+&quot;); int g=0,f=0,l=0,j=0; printf(&quot;请输入需要录入的人数： &quot;); scanf(&quot;%d&quot;,&amp;l); printf(&quot;请录入学生信息\\n&quot;); for(f=0;f&lt;l;f++) &#123; scanf(&quot;%d %s %s %d %s&quot;, &amp;stub[f].stu_num,&amp;stub[f].name,&amp;stub[f].sex,&amp;stub[f].age,&amp;stub[f].Classname); &#125; for(g=0;g&lt;f;g++) &#123; for(j=0;j&lt;c;j++) &#123; if( stub[g].stu_num==stu[j].stu_num) &#123; printf(&quot;已存在该学号,录入失败\\n&quot;); return ; &#125; &#125; fprintf(fp,&quot;%d %s %s %d %s\\n&quot;, stub[g].stu_num,stub[g].name,stub[g].sex,stub[g].age,stub[g].Classname); &#125; printf(&quot;录入成功！\\n&quot;); fclose(fp); &#125; /*显示*/ void Print(struct Stu*head) &#123; FILE*fp; struct Stu*p; fp=fopen(&quot;D:\\\\实验室\\\\学生证管理系统\\\\学生证信息.txt&quot;,&quot;r&quot;); p=(struct Stu*)malloc(sizeof(struct Stu)); if(fp==NULL) &#123; printf(&quot;文件打开错误！\\n&quot;); &#125; m=0; printf(&quot;学号 姓名 性别 年龄 班级\\n&quot;); while(!feof(fp)) &#123; fscanf(fp,&quot;%d %s %s %d %s\\n&quot;,&amp;p-&gt;stu_num ,&amp;p-&gt;name,&amp;p-&gt;sex,&amp;p-&gt;age,&amp;p-&gt;Classname); printf(&quot;%d%10s%10s%10d%10s\\n&quot;,p-&gt;stu_num,p-&gt;name,p-&gt;sex,p-&gt;age,p-&gt;Classname); m++; p=(struct Stu*)malloc(sizeof(struct Stu)); &#125; fclose(fp); &#125; /*删除*/ int Delect(struct Stu *head) &#123; struct Stu stu[100]; struct Stu stub[99];//删除后的结构体数组 int num;//学号 int i; int find=0; printf(&quot;\\n请输入需要删除的学生学号：&quot;); scanf(&quot;%d&quot;, &amp;num); FILE *fp; fp=fopen(&quot;D:\\\\实验室\\\\学生证管理系统\\\\学生证信息.txt&quot;,&quot;r&quot;); if(fp==NULL) &#123; printf(&quot;打开文件失败！\\n&quot;); &#125; int c=0; int index=0;//用于记录目标序号 while(fscanf(fp,&quot;%d %s %s %d %s\\n&quot;, &amp;stu[c].stu_num,&amp;stu[c].name,&amp;stu[c].sex,&amp;stu[c].age,&amp;stu[c].Classname)!=EOF)//不为空 &#123; if(num==stu[c].stu_num) &#123; find = 1;//根据学号查找，找到赋值为1 index = c;//记录编号 &#125; c++; &#125; fclose(fp); if(c==0) &#123; printf(&quot;不存在学生信息\\n&quot;); return 1; &#125; if(find==0) &#123; printf(&quot;不存在该学生成绩信息\\n&quot;); return 1; &#125; else &#123; for(i=0;i&lt;c;i++) &#123; if(i &lt; index) &#123; stub[i] = stu[i]; &#125; else &#123; stub[i] = stu[i+1]; &#125; &#125; fp=fopen(&quot;D:\\\\实验室\\\\学生证管理系统\\\\学生证信息.txt&quot;,&quot;w&quot;); //写入数据 printf(&quot;学号 姓名 性别 年龄 班级\\n&quot;); for(i=0;i&lt;c-1;i++) &#123; fprintf(fp,&quot;%d %s %s %d %s\\n&quot;, stub[i].stu_num,stub[i].name,stub[i].sex,stub[i].age,stub[i].Classname); printf(&quot;%d%10s%10s%10d%10s\\n&quot;, stub[i].stu_num,stub[i].name,stub[i].sex,stub[i].age,stub[i].Classname); &#125; fclose(fp); printf(&quot;学号为%d的学生成绩删除成功\\n&quot;,num); return 1; &#125; &#125; /*修改*/ void Modify(struct Stu*head) &#123; struct Stu stu[100]; FILE *fp; int num; int i,find=0; printf(&quot;请输入要修改的学生学号:&quot;); scanf(&quot;%d&quot;,&amp;num); fp=fopen(&quot;D:\\\\实验室\\\\学生证管理系统\\\\学生证信息.txt&quot;,&quot;r&quot;); if(fp==NULL) &#123; printf(&quot;文件打开失败!\\n&quot;); return; &#125; int c=0; while(!feof(fp)) &#123; fscanf(fp,&quot;%d %s %s %d %s\\n&quot;, &amp;stu[c].stu_num,&amp;stu[c].name,&amp;stu[c].sex,&amp;stu[c].age,&amp;stu[c].Classname); if(num==stu[c].stu_num) &#123; find=1; printf(&quot;需要修改的内容1.姓名 2.年龄 3.班级 4.修改完毕:&quot;); scanf(&quot;%d&quot;,&amp;i); while(i!=4) &#123; if(i==1) &#123; printf(&quot;\\n已找到你要修改成绩的同学,请输入他的新名字:\\n&quot;); scanf(&quot;%s&quot;,&amp;stu[c].name); printf(&quot;\\n&quot;); &#125; if(i==2) &#123; printf(&quot;\\n已找到你要修改成绩的同学,请输入他的新年龄:\\n&quot;); scanf(&quot;%d&quot;,&amp;stu[c].age); printf(&quot;\\n&quot;); &#125; if(i==3) &#123; printf(&quot;\\n已找到你要修改成绩的同学,请输入他的新班级:\\n&quot;); scanf(&quot;%s&quot;,&amp;stu[c].Classname); printf(&quot;\\n&quot;); &#125; if(i&gt;4) &#123; break; &#125; printf(&quot;\\n需要修改的内容1.姓名 2.年龄 3.班级 4.修改完毕:&quot;); scanf(&quot;%d&quot;,&amp;i); &#125; //修改操作 &#125; c++; &#125; fclose(fp); if(find==0) &#123; printf(&quot;没有找到要删除的学生记录!\\n&quot;); exit (0); &#125; else &#123; fp=fopen(&quot;D:\\\\实验室\\\\学生证管理系统\\\\学生证信息.txt&quot;,&quot;w&quot;); int i; for(i=0;i&lt;c;i++) &#123; fprintf(fp,&quot;%d %s %s %d %s\\n&quot;, stu[i].stu_num,stu[i].name,stu[i].sex,stu[i].age,stu[i].Classname); printf(&quot;%d%10s%10s%10d%10s\\n&quot;, stu[i].stu_num,stu[i].name,stu[i].sex,stu[i].age,stu[i].Classname); &#125; fclose(fp); printf(&quot;学号为%d同学的信息修改成功!\\n&quot;,num); &#125; return; &#125; /*排序*/ void Sort() &#123; struct Stu stub[100]; struct Stu stu[100]; int i,j; FILE *fp; fp=fopen(&quot;D:\\\\实验室\\\\学生证管理系统\\\\学生证信息.txt&quot;,&quot;r&quot;); if(fp==NULL) &#123; printf(&quot;打开文件失败！\\n&quot;); getch(); exit(0); &#125; int c = 0; int v,x; while(!feof(fp)) &#123; fscanf(fp,&quot;%d %s %s %d %s\\n&quot;, &amp;stu[c].stu_num,&amp;stu[c].name,&amp;stu[c].sex,&amp;stu[c].age,&amp;stu[c].Classname); c++; &#125; printf(&quot;请选择排序方式 1.按班级 2.按学号&quot;); scanf(&quot;%d&quot;,&amp;x); if(x==1) &#123; for(i=0;i&lt;c-1;i++) &#123; for(j=0;j&lt;c-i-1;j++) &#123; if(strcmp(stu[j].Classname,stu[j+1].Classname)&gt;0) &#123; stub[j]=stu[j] ; stu[j]=stu[j+1]; stu[j+1]=stub[j]; &#125; &#125; &#125; &#125; if(x==2) &#123; printf(&quot;请选择排序方式 1.降序 2.升序 ：&quot;); scanf(&quot;%d&quot;,&amp;v); if(v==1) &#123; for(i=0;i&lt;c-1;i++) &#123; for(j=0;j&lt;c-i-1;j++) &#123; if(stu[j].stu_num &lt; stu[j+1].stu_num)//降序 &#123; stub[j]=stu[j] ; stu[j]=stu[j+1]; stu[j+1]=stub[j]; &#125; &#125; &#125; &#125; else if(v==2) &#123; for(i=0;i&lt;c-1;i++) &#123; for(j=0;j&lt;c-i-1;j++) &#123; if(stu[j].stu_num &gt; stu[j+1].stu_num) //升序 &#123; stub[j]=stu[j+1] ; stu[j+1]=stu[j]; stu[j]=stub[j]; &#125; &#125; &#125; &#125; else &#123; printf(&quot;请选择1~2的数字\\n&quot;); Sort(); &#125; &#125; fclose(fp); fp=fopen(&quot;D:\\\\实验室\\\\学生证管理系统\\\\学生证信息.txt&quot;,&quot;w&quot;); //写入数据 printf(&quot;学号 姓名 性别 年龄 班级\\n&quot;); for(i=0;i&lt;c;i++) &#123; fprintf(fp,&quot;%d %s %s %d %s\\n&quot;, stu[i].stu_num,stu[i].name,stu[i].sex,stu[i].age,stu[i].Classname); printf(&quot;%d%10s%10s%10d%10s\\n&quot;, stu[i].stu_num,stu[i].name,stu[i].sex,stu[i].age,stu[i].Classname); &#125; printf(&quot;排序成功!\\n&quot;); fclose(fp); &#125; /*查询*/ //姓名 void searchname() &#123; struct Stu stu[100]; char names[11]; printf(&quot;请输入你要查询学生的姓名：&quot;); scanf(&quot;%s&quot;,&amp;names); FILE *fp; fp=fopen(&quot;D:\\\\实验室\\\\学生证管理系统\\\\学生证信息.txt&quot;,&quot;r&quot;); if(fp==NULL) &#123; printf(&quot;打开文件失败！\\n&quot;); exit(0); &#125; int c = 0; while(fscanf(fp,&quot;%d %s %s %d %s\\n&quot;, &amp;stu[c].stu_num,&amp;stu[c].name,&amp;stu[c].sex,&amp;stu[c].age,&amp;stu[c].Classname)!=EOF) &#123; c++; &#125; int i; printf(&quot;学号 姓名 性别 年龄 班级\\n&quot;); for(i=0;i&lt;c;i++) &#123; if(strcmp(names,stu[i].name)==0) &#123; printf(&quot;***已找到该学生信息***\\n&quot;); printf(&quot;%d%10s%10s%10d%10s\\n&quot;, stu[i].stu_num,stu[i].name,stu[i].sex,stu[i].age,stu[i].Classname); fclose(fp); return; &#125; &#125; printf(&quot;未找到要查询学生的成绩！\\n&quot;); fclose(fp); return; &#125; //班级 void classname() &#123; struct Stu stu[100]; char classs[11]; printf(&quot;请输入你要查询学生的班级名称：&quot;); scanf(&quot;%s&quot;,&amp;classs); FILE *fp; fp=fopen(&quot;D:\\\\实验室\\\\学生证管理系统\\\\学生证信息.txt&quot;,&quot;r&quot;); if(fp==NULL) &#123; printf(&quot;打开文件失败！\\n&quot;); exit(0); &#125; int c = 0; while(fscanf(fp,&quot;%d %s %s %d %s\\n&quot;, &amp;stu[c].stu_num,&amp;stu[c].name,&amp;stu[c].sex,&amp;stu[c].age,&amp;stu[c].Classname)!=EOF) &#123; c++; &#125; int i; printf(&quot;学号 姓名 性别 年龄 班级\\n&quot;); for(i=0;i&lt;c;i++) &#123; if(strcmp(classs,stu[i].Classname)==0) &#123; printf(&quot;***已找到学生信息***\\n&quot;); printf(&quot;%d%10s%10s%10d%10s\\n&quot;, stu[i].stu_num,stu[i].name,stu[i].sex,stu[i].age,stu[i].Classname); &#125; &#125; printf(&quot;未找到要查询学生的成绩！\\n&quot;); fclose(fp); return; &#125; //学号 void stunums() &#123; struct Stu stu[100]; int nums; printf(&quot;请输入你要查询学生的学号：&quot;); scanf(&quot;%d&quot;,&amp;nums); FILE *fp; fp=fopen(&quot;D:\\\\实验室\\\\学生证管理系统\\\\学生证信息.txt&quot;,&quot;r&quot;); if(fp==NULL) &#123; printf(&quot;打开文件失败！\\n&quot;); exit(0); &#125; int c = 0; while(fscanf(fp,&quot;%d %s %s %d %s\\n&quot;, &amp;stu[c].stu_num,&amp;stu[c].name,&amp;stu[c].sex,&amp;stu[c].age,&amp;stu[c].Classname)!=EOF) &#123; c++; &#125; int i; printf(&quot;学号 姓名 性别 年龄 班级\\n&quot;); for(i=0;i&lt;c;i++) &#123; if(stu[i].stu_num==nums) &#123; printf(&quot;***已找到该学生信息***\\n&quot;); printf(&quot;%d%10s%10s%10d%10s\\n&quot;, stu[i].stu_num,stu[i].name,stu[i].sex,stu[i].age,stu[i].Classname); fclose(fp); return; &#125; &#125; printf(&quot;未找到要查询学生的成绩！\\n&quot;); fclose(fp); return; &#125;","categories":[],"tags":[]},{"title":"","slug":"第一篇博客","date":"2020-12-01T12:03:53.346Z","updated":"2020-12-01T12:03:23.778Z","comments":true,"path":"2020/12/01/第一篇博客/","link":"","permalink":"http://example.com/2020/12/01/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"第一篇博客 一、构建博客步骤1.在GitHub网站上注册并创建好属于自己的仓库； 2.下载git和node，下载好后打开cmd测试是否安装成功； 3.安装hexo，并输入一系列指令，启动本地服务器，成功构建博客； 4.编辑_config.yml文件，并输入指令，使本地内容链接到服务器上； 5.设秘钥； 6.在指定的地方将博客内容通过一系列指令上传到自己的博客上； 7.改主题，在_config.yml文件中找到themes改名称。 二、构建过程中遇到的困难1.各种error当时解决方法就是上百度搜索，一般他会教输入其他的代码，但在此次我的博客构建中均无效，最终均以删除重新下载解决。 2.无法将本地博客连到网站上原因：在改_config.yml文件内容时没有注意中英文切换，导致输入“：”时输入了中文的冒号，因而使程序错误。 三、总结这是我第二次在网站上发表第二篇博客，上个周在学长和组员的帮助下成功搭建了属于自己的博客，但是由于个人操作失误，这个周又重新搞了一次，但是，很明显比第一次顺利很多，搭建步骤并不是很复杂，主要是在执行过程中出现的小错误比较拖时间，但是修正好之后也就不会有什么太大的问题了。这个任务是我加入实验室的第一项作业，希望我能尽快赶上大家的进度，和实验室其他成员一起加油！","categories":[],"tags":[]},{"title":"blog","slug":"blog’","date":"2020-12-01T07:05:36.000Z","updated":"2020-12-01T07:13:24.759Z","comments":true,"path":"2020/12/01/blog’/","link":"","permalink":"http://example.com/2020/12/01/blog%E2%80%99/","excerpt":"","text":"这是我第二次在网站上发表第二篇博客，上个周在学长和组员的帮助下成功搭建了属于自己的博客，但是由于个人操作失误，这个周又重新搞了一次，但是，很明显比第一次顺利很多，搭建步骤并不是很复杂，主要是在执行过程中出现的小错误比较拖时间，但是修正好之后也就不会有什么太大的问题了。这个任务是我加入实验室的第一项作业，希望我能尽快赶上大家的进度，和实验室其他成员一起加油！","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2020-12-01T06:14:13.585Z","updated":"2020-12-01T06:14:13.586Z","comments":true,"path":"2020/12/01/hello-world/","link":"","permalink":"http://example.com/2020/12/01/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[]}